
#import "../contracts/main.jsligo" "Factory"

type fa2_storage = Factory.NFT_FA2.Storage.t;
type ext = Factory.NFT_FA2.extension;
type ext_fa2_storage = fa2_storage<ext>;

let assert_string_failure (res : test_exec_result) (expected : string) : unit =
  let expected = Test.eval(expected);
  match(res, {
    Fail: (Rejected (actual,_)) => assert (Test.michelson_equal actual expected)
    Fail: (Other) => failwith "contract failed for an unknown reason"
    Success: (_gas: nat) => failwith "contract did not failed but was expected to fail"
  });

let test =
    // setup 4 accounts 
    let () = Test.reset_state(4 as nat, (list([]) : list<tez>));
    let alice: address = Test.nth_bootstrap_account(0);
    let bob: address = Test.nth_bootstrap_account 1;
    let steven: address = Test.nth_bootstrap_account 2;
    let frank: address = Test.nth_bootstrap_account 3;

    // originate Factory smart contract
    let init_storage : Factory.Storage.t = { 
        all_collections=(Big_map.empty : (Factory.Storage.collectionContract, Factory.Storage.collectionOwner) big_map);
        owned_collections=(Big_map.empty : (Factory.Storage.collectionOwner, Factory.Storage.collectionContract list) big_map);
    };
    let (addr,_,_) = Test.originate Factory.main(init_storage, 0 as tez);;

    let _generates_collection_1_should_works = 
        let () = Test.log("_generates_collection_1_should_works");

        let x : Factory.parameter contract = Test.to_contract addr;

        // prepare arguments for generating a new collection
        let token_ids : nat list = [(1 as nat)];
        let token_info_1 = (Map.literal[
            ("QRcode", 0x623d82eff132);
        ] : (string, bytes) map);
        let token_metadata = (Big_map.literal [
            ((1 as nat), ({token_id=(1 as nat);token_info=token_info_1;} : Factory.NFT_FA2.NFT.TokenMetadata.data));
        ] : Factory.NFT_FA2.NFT.TokenMetadata.t);

        // call GenerateCollection entrypoint
        let () = Test.set_source alice;
        let gencol_args : Factory.Parameter.generate_collection_param = {name="alice_collection_1"; token_ids=token_ids; token_metas=token_metadata};
        let _ = Test.transfer_to_contract_exn x (GenerateCollection(gencol_args)) (1000000 as mutez);

        // verify FA2 has been created
        let s : Factory.storage = Test.get_storage addr;
        let colls : list<address> = match(Big_map.find_opt(alice, s.owned_collections), {
            None: () => (list([]) as list<address>),
            Some: (x: list<address> => x
        });
        let owned_coll_size = List.fold( (([acc, elt] : [nat, address]) : nat => acc + (1 as nat)), colls, (0 as nat));
        //let owned_coll_size : nat = Set.size colls in 
        assert (owned_coll_size == (1 as nat))
   ;
    let _mint_token2_collection_1_should_works = 
        let () = Test.log("_mint_token2_collection_1_should_works");
        //let x : Factory.parameter contract = Test.to_contract addr;

        // Retrieve address of collection 1
        let s_before : Factory.storage = Test.get_storage addr;
        let colls_before : list<address> = match(Big_map.find_opt(alice, s_before.owned_collections), {
            None: () => (list([]) : list<address>),
            Some (oc: list<address>) => oc
        });
        //let colls_before_list : address list = Set.fold (fun(acc, i : address list * address) -> i :: acc) colls_before ([] : address list);
        let address1 : address = Option.unopt (List.head_opt colls_before);

        // prepare mint arguments
        //let () = Test.log("alice mint token 2 in collection 1");
        let extra_token_id : nat = (2 as nat);
        let extra_token_ids : nat list = [extra_token_id];
        let extra_token_info = (Map.literal[ ("QRcode", 0x6269c0f1a821); ] : (string, bytes) map);
        let extra_token_metadata = (Big_map.literal [ (extra_token_id, extra_token_info); ] : (nat, (string, bytes) map) big_map);

        // call MINT
        let () = Test.set_source alice;
        let taddr1 = (Test.cast_address address1 : (Factory.NFT_FA2.parameter, ext_fa2_storage) typed_address);
        let fa2_1 : Factory.NFT_FA2.parameter contract = Test.to_contract taddr1;
        let mint_args : Factory.NFT_FA2.NFT.mint_param = { ids=extra_token_ids; metas=extra_token_metadata };
        let _ = Test.transfer_to_contract_exn(fa2_1, (Mint(mint_args)), (0 as mutez));

        // verify token2 is created and owned by alice
        //let () = Test.log("check new token 2");
        let fa2_1_s : ext_fa2_storage = Test.get_storage taddr1;
        let () = assert(Factory.NFT_FA2.Storage.is_owner_of fa2_1_s alice (2 as nat));
        "OK"
   ;
    let _mint_token3_collection_1_should_fail = 
        let () = Test.log("_mint_token3_collection_1_should_fail");

        let x : Factory.parameter contract = Test.to_contract addr;

        // Retrieve address of collection 1
        let s_before : Factory.storage = Test.get_storage addr;
        let colls_before : list<address> = match(Big_map.find_opt(alice, s_before.owned_collections), {
            None: () => (list([]) as list<address>),
            Some: (oc: list<address>) => oc
        });
        //let colls_before_list : address list = Set.fold (fun(acc, i : address list * address) -> i :: acc) colls_before ([] : address list);
        let address1 : address = Option.unopt (List.head_opt colls_before);

        // prepare mint arguments
        //let () = Test.log("alice mint token 3 in collection 1");
        let extra_token_id : nat = (3 as nat);
        let extra_token_qrcode : bytes = 0x92a77bf1a4c5;
        let extra_token_ids : nat list = [extra_token_id];
        let extra_token_info = (Map.literal[ ("QRcode", extra_token_qrcode); ] : (string, bytes) map);
        let extra_token_metadata = (Big_map.literal [ (extra_token_id, extra_token_info); ] : (nat, (string, bytes) map) big_map);

        // call MINT
        let () = Test.set_source bob;
        let taddr1 = (Test.cast_address address1 : (Factory.NFT_FA2.parameter, ext_fa2_storage) typed_address);
        let fa2_1 : Factory.NFT_FA2.parameter contract = Test.to_contract taddr1;
        let mint_args : Factory.NFT_FA2.NFT.mint_param = { ids=extra_token_ids; metas=extra_token_metadata };
        let fail_mint_token3 = Test.transfer_to_contract(fa2_1, (Mint(mint_args)), 0 as mutez);
        assert_string_failure fail_mint_token3 Factory.NFT_FA2.Errors.only_admin
   ;
    let _generates_collection_2_with_5_tokens_should_works = 
        let () = Test.log("_generates_collection_2_with_5_tokens_should_works");
        // check existing collections
        let s_before : Factory.storage = Test.get_storage addr;
        let colls_before : list<address> = match(Big_map.find_opt(alice, s_before.owned_collections), {
            None: () => (list([]) as list<address>),
            Some: (x: list<address>) => x
        });
        //let colls_before_list : address list = Set.fold (fun(acc, i : address list * address) -> i :: acc) colls_before ([] : address list);
        let address1 : address = Option.unopt (List.head_opt colls_before);

        let x : contract<Factory.parameter> = Test.to_contract(addr);

        //let () = Test.log("alice generates a collection 2");
        let () = Test.set_source(alice);
 
        // set new collection 2
        let token_ids : nat list = [(1 as nat); (2 as nat); (3 as nat) ;(4 as nat); (5 as nat)];

        // add specific metadata for each token
        let token_info_1 = (Map.literal[ ("QRcode", 0x623d82eff132); ] : (string, bytes) map);
        let token_info_2 = (Map.literal[ ("QRcode", 0x49aa82eff132); ] : (string, bytes) map);
        let token_info_3 = (Map.literal[ ("QRcode", 0xab3442eff132); ] : (string, bytes) map);
        let token_info_4 = (Map.literal[ ("QRcode", 0xdeadbeefdead); ] : (string, bytes) map);
        let token_info_5 = (Map.literal[ ("QRcode", 0xdeadbeefbeef); ] : (string, bytes) map);

        let token_metadata = (Big_map.literal [
            ((1 as nat), ({token_id=(1 as nat);token_info=token_info_1;} : Factory.NFT_FA2.NFT.TokenMetadata.data));
            ((2 as nat), ({token_id=(2 as nat);token_info=token_info_2;} : Factory.NFT_FA2.NFT.TokenMetadata.data));
            ((3 as nat), ({token_id=(3 as nat);token_info=token_info_3;} : Factory.NFT_FA2.NFT.TokenMetadata.data));
            ((4 as nat), ({token_id=(4 as nat);token_info=token_info_4;} : Factory.NFT_FA2.NFT.TokenMetadata.data));
            ((5 as nat), ({token_id=(5 as nat);token_info=token_info_5;} : Factory.NFT_FA2.NFT.TokenMetadata.data));
        ] : Factory.NFT_FA2.NFT.TokenMetadata.t);

        // add global metadatas to all tokens
        let collection_name_bytes : bytes = Bytes.pack "Pietrus 2022";
        let global_metadatas : (string, bytes) map = (Map.literal[ ("collection", collection_name_bytes)] : (string, bytes) map) in 
        let new_token_metadata = Factory.NFT_FA2.NFT.TokenMetadata.add_global_metadata token_ids token_metadata global_metadatas;

        // generate collection
        let gencol_args : Factory.Parameter.generate_collection_param = {name="alice_collection_1"; token_ids=token_ids; token_metas=new_token_metadata};
        let _ = Test.transfer_to_contract_exn(x, (GenerateCollection(gencol_args)), 1000000 as mutez);

        let s : Factory.storage = Test.get_storage(addr);
        // verify number of collections
        let colls : list<address> = match Big_map.find_opt(alice, s.owned_collections), {
            None: () => (list([]) : list<address>),
            Some: (x: list<address>) => x
        });
        //let owned_coll_size : nat = Set.size colls in 
        let owned_coll_size = List.fold( ( ([acc, elt] : [nat, address]) : nat => acc + (1 as nat)), colls, (0 as nat));
        let () = assert (owned_coll_size == (2 as nat));

        let parse_metas = ([acc, elt] : [[address, big_map<list<nat>, Factory.NFT_FA2.NFT.TokenMetadata.t>], address]) : [address, big_map<list<nat>, Factory.NFT_FA2.NFT.TokenMetadata.t>] => { 
            let taddr = (Test.cast_address elt : (Factory.NFT_FA2.parameter, ext_fa2_storage) typed_address);
            let fa2_store : ext_fa2_storage = Test.get_storage taddr;
            Big_map.add elt (fa2_store.token_ids, fa2_store.token_metadata) acc
        });
        let all_tokens : (address, (nat list * Factory.NFT_FA2.NFT.TokenMetadata.t))big_map = List.fold parse_metas colls (Big_map.empty : (address, (nat list * Factory.NFT_FA2.NFT.TokenMetadata.t) )big_map) in 
        
        // Retrieve collection 2 address
        //let colls_list : address list = Set.fold (fun(acc, i : address list * address) -> i :: acc) colls ([] : address list);
        // find address of collection 2
        let get_next_address([lst, blacklist] : [list<address>, list<address>]) : address => {
            let filter = ([acc, elt] : [[list<address>, list<address>], address]) : [list<address>, list<address>] => { 
                let is_in_list([res, i] : [[bool, address], address]) : (bool * address) => if res[0] then res else [(i == res[1]), res[1]];
                let is_blacklisted, _ = List.fold(is_in_list, acc.1, [false, elt]);
                if is_blacklisted then acc else [[elt, ...acc[0]], acc[1]] 
            };
            let filtered_list, _ = List.fold(filter, lst, ((list([]) as list<address>), blacklist));
            Option.unopt (List.head_opt filtered_list)
        };
        let address2 : address = get_next_address(colls, colls_before);

        // verify token_ids of collection 1
        let collection1_info : [list<nat>, Factory.NFT_FA2.NFT.TokenMetadata.t] = match(Big_map.find_opt(address1, all_tokens), {
            None: () => (failwith("No metadata for collection 1") as [list<nat>, Factory.NFT_FA2.NFT.TokenMetadata.t]),
            Some: (info: [list<nat>, Factory.NFT_FA2.NFT.TokenMetadata.t]) => info
        });
        //let () = Test.log(collection1_info.0);
        let () = assert(collection1_info.0 == [(2 as nat), (1 as nat)]);
        // verify token_ids of collection 2 
        let collection2_info : [list<nat>, Factory.NFT_FA2.NFT.TokenMetadata.t] = match(Big_map.find_opt(address2, all_tokens), {
            None: () => (failwith("No metadata for collection 2") as [list<nat>, Factory.NFT_FA2.NFT.TokenMetadata.t]),
            Some: (info: [list<nat>, Factory.NFT_FA2.NFT.TokenMetadata.t]) => info
        });
        let () = assert(collection2_info.0 == [(1 as nat), (2 as nat), (3 as nat), (4 as nat), (5 as nat)]);
        // verify metadata of token 3 of collection 2
        let collection2_metas : Factory.NFT_FA2.NFT.TokenMetadata.t = collection2_info.1;
        let collection2_metas_tok3 : Factory.NFT_FA2.NFT.TokenMetadata.data = match(Big_map.find_opt((3 as nat), collection2_metas), {
            None: () => (failwith("No token 3 in this collection") as Factory.NFT_FA2.NFT.TokenMetadata.data),
            Some: (info: Factory.NFT_FA2.NFT.TokenMetadata.data) => info
        });
        let () = assert(collection2_metas_tok3.token_info == (Map.literal[ ("QRcode", 0xab3442eff132); ("collection", collection_name_bytes)] : (string, bytes) map));
        // verify metadata of token 4 of collection 2
        let collection2_metas_tok4 : Factory.NFT_FA2.NFT.TokenMetadata.data = match(Big_map.find_opt((4 as nat), collection2_metas), {
            None: () => (failwith("No token 4 in this collection") as Factory.NFT_FA2.NFT.TokenMetadata.data),
            Some: (info: Factory.NFT_FA2.NFT.TokenMetadata.data) => info
        });
        let () = assert(collection2_metas_tok4.token_info == (Map.literal[ ("QRcode", 0xdeadbeefdead); ("collection", collection_name_bytes)] : (string, bytes) map));
        "OK" 
    ;
    let _transfer_token1_collection_2_should_works = 
        let () = Test.log("_transfer_token1_collection_2_should_works");
        // retrieve address collection 2
        let s_before : Factory.storage = Test.get_storage addr;
        let colls_before : list<address> = match(Big_map.find_opt(alice, s_before.owned_collections), {
            None: () => (list([]) : list<address>),
            Some: (x: list<address>) => x
        });
        let address2 : address = Option.unopt (List.head_opt colls_before);

        let () = Test.log("alice transfer tok 1 to bob") in 
        let () = Test.set_source alice;
        let taddr2 = (Test.cast_address address2 : (Factory.NFT_FA2.parameter, ext_fa2_storage) typed_address);
        let fa2_2 : Factory.NFT_FA2.parameter contract = Test.to_contract taddr2;
        let transfer1_args : Factory.NFT_FA2.NFT.transfer = [{ from_=alice; tx=[{to_=bob;token_id=(1 as nat)}] }];
        let _ = Test.transfer_to_contract_exn(fa2_2, (Transfer(transfer1_args)), 0 as mutez);

        let fa2_2_s : ext_fa2_storage = Test.get_storage taddr2;
        let () = assert(Factory.NFT_FA2.Storage.is_owner_of fa2_2_s bob (1 as nat));
        let () = assert(Factory.NFT_FA2.get_usage_of fa2_2_s (1 as nat) == (1 as nat));
        let () = assert(Factory.NFT_FA2.Storage.is_owner_of fa2_2_s alice (2 as nat)) in 
        let () = assert(Factory.NFT_FA2.get_usage_of fa2_2_s (2 as nat) == (0 as nat));
        let () = assert(Factory.NFT_FA2.Storage.is_owner_of fa2_2_s alice (3 as nat));
        let () = assert(Factory.NFT_FA2.get_usage_of fa2_2_s (3 as nat) == (0 as nat));
        let () = assert(Factory.NFT_FA2.Storage.is_owner_of fa2_2_s alice (4 as nat));
        let () = assert(Factory.NFT_FA2.get_usage_of fa2_2_s (4 as nat) == (0 as nat));
        let () = assert(Factory.NFT_FA2.Storage.is_owner_of fa2_2_s alice (5 as nat));
        let () = assert(Factory.NFT_FA2.get_usage_of fa2_2_s (5 as nat) == (0 as nat));

        let () = Test.log("bob transfer tok 1 to steven") in 
        let () = Test.set_source bob;
        let fa2_2 : Factory.NFT_FA2.parameter contract = Test.to_contract taddr2;
        let transfer1_args : Factory.NFT_FA2.NFT.transfer = [{ from_=bob; tx=[{to_=steven;token_id=(1 as nat)}] }];
        let _ = Test.transfer_to_contract_exn(fa2_2, (Transfer(transfer1_args)), 0 as mutez);

        let fa2_2_s : ext_fa2_storage = Test.get_storage taddr2;
        let () = assert(Factory.NFT_FA2.Storage.is_owner_of fa2_2_s steven (1 as nat));
        let () = assert(Factory.NFT_FA2.get_usage_of fa2_2_s (1 as nat) == (2 as nat));
        "OK" 
   ;
    ()