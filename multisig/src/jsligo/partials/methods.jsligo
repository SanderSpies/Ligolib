#import "types.jsligo" "T"
#import "error.jsligo" "E"


// -----------------
// --  CONSTANTS  --
// -----------------
const no_operation:  list<operation> = list([]);


// -----------------
// --  INTERNALS  --
// -----------------

const sendFA2 = ([transfers, target_fa2] : [T.FA2.transfer, address]): operation => {
    const fa2_contract_opt: option<contract<T.FA2.transfer>>  = Tezos.get_entrypoint_opt ("%transfer", target_fa2);
    const transfer_fa2: contract<T.FA2.transfer> = match (fa2_contract_opt, {
        Some: (c: contract<T.FA2.transfer>) => c,
        None: () => (failwith(E.unknown_contract_entrypoint) as contract<T.FA2.transfer>)
    });
    return Tezos.transaction(transfers, 0 as mutez, transfer_fa2);
};


// ------------------
// -- ENTRY POINTS --
// ------------------

const create_proposal = ([params, storage_multisig]: [T.proposal_params, T.storage_multisig]): T.return_multisig => {
    assert_with_error(Set.mem(Tezos.sender, storage_multisig.signers), E.only_signer);
    assert_with_error (Tezos.amount == (0 as tez), E.amount_must_be_zero_tez);
    const new_proposal: T.proposal = {
        approved_signers: Set.add(Tezos.sender, Set.empty) as set<address>,
        executed: false,
        number_of_signers: 1 as nat,
        target_fa2: params.target_fa2,
        transfers: params.transfers,
        timestamp: Tezos.now,
    };
    const proposal_map: big_map<nat, T.proposal> = Big_map.add(storage_multisig.proposal_counter, new_proposal, storage_multisig.proposal_map);
    return [no_operation, {...storage_multisig, proposal_counter: storage_multisig.proposal_counter + (1 as nat), proposal_map: proposal_map}]
};

const sign = ([proposal_id, storage_multisig]: [nat, T.storage_multisig]): T.return_multisig => {
    assert_with_error(Set.mem(Tezos.sender, storage_multisig.signers), E.only_signer);
    let target_request: T.proposal = match (Big_map.find_opt(proposal_id, storage_multisig.proposal_map), {
        Some: (op: T.proposal) => op,
        None: () => (failwith(E.no_proposal_exist))
    });
    assert_with_error(!Set.mem(Tezos.sender, target_request.approved_signers), E.has_already_signed); // quite useless
    target_request = ({
            ...target_request,
            approved_signers: Set.add(Tezos.sender, target_request.approved_signers),
            number_of_signers: target_request.number_of_signers + (1 as nat)
        });
    let operations: list<operation> = no_operation;
    if (Set.size(target_request.approved_signers) >= storage_multisig.threshold) {
        target_request = ({
            ...target_request,
            executed: true
        });
        operations = list([
            sendFA2(
                target_request.transfers,
                target_request.target_fa2
            )
        ]);
    }
    const final_proposal_map: big_map<nat, T.proposal> = Big_map.update(
        proposal_id,
        Some(target_request),
        storage_multisig.proposal_map
    )
    return [operations, {...storage_multisig, proposal_map: final_proposal_map}];
};
