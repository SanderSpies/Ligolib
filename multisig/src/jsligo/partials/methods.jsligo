#include "types.jsligo"
#include "error.jsligo"

// -----------------
// --  CONSTANTS  --
// -----------------
const max_duration_in_sec: nat  = 6048000 as nat; // 10 weeks
const no_operation:  list<operation> = list([]);
const empty_nat_list: list<nat> = list([]);


// -----------------
// --  INTERNALS  --
// -----------------

const sendFA12 = ([token_amount, target_to, target_fa12] : [nat, address, address]): operation => {
    const fa12_contract_opt: option<contract<fa12_transfer>>  = Tezos.get_entrypoint_opt ("%transfer", target_fa12);
    const transfer_fa12: contract<fa12_transfer> = match (fa12_contract_opt, {
        Some: (c: contract<fa12_transfer>) => c,
        None: () => (failwith(unknown_contract_entrypoint) as contract<fa12_transfer>)
    });
    const transfer_param: fa12_transfer = [Tezos.self_address, [target_to, token_amount]];
    return Tezos.transaction(transfer_param, 0 as mutez, transfer_fa12);
};


// ------------------
// -- ENTRY POINTS --
// ------------------

const create_operation = ([params, storage_multisig]: [operation_params, storage_multisig]): return_multisig => {
    const check_is_signer: unit = assert_with_error(Set.mem(Tezos.sender, storage_multisig.signers), only_signer);
    const check_if_no_tez: unit = assert_with_error (Tezos.amount == (0 as tez), amount_must_be_zero_tez);
    const new_operation: operation_request = {
        target_to: params.target_to,
        target_fa12: params.target_fa12,
        token_amount: params.token_amount,
        timestamp: Tezos.now,
        approved_signers: Set.empty as set<address>,
        executed: false
    };
    const operation_map: big_map<nat, operation_request> = Big_map.add(storage_multisig.operation_counter, new_operation, storage_multisig.operation_map);
    return [no_operation, {...storage_multisig, operation_counter: storage_multisig.operation_counter + (1 as nat), operation_map: operation_map}]
}; // PEDAGO: amount can be zero

const sign = ([operation_request_id, storage_multisig]: [nat, storage_multisig]): return_multisig => {
    const check_is_signer: unit = assert_with_error(Set.mem(Tezos.sender, storage_multisig.signers), only_signer);
    const check_as_already_signed: unit = assert_with_error(Set.mem(Tezos.sender, storage_multisig.signers), only_signer); // quite useless
    let target_request: operation_request = match (Big_map.find_opt(operation_request_id, storage_multisig.operation_map), {
        Some: (op: operation_request) => ({
            ...op,
            approved_signers: Set.add(Tezos.sender, op.approved_signers)
        }),
        None: () => (failwith(unknown_operation_request))
    });
    let operations: list<operation> = no_operation;
    if (Set.size(target_request.approved_signers) >= storage_multisig.threshold) {
        operations = list([
            sendFA12(
                target_request.token_amount,
                target_request.target_to,
                target_request.target_fa12
            )
        ]);
        target_request = ({
            ...target_request,
            executed: true
        });
    }
    const final_operation_map: big_map<nat, operation_request> = Big_map.update(
        operation_request_id,
        Some(target_request),
        storage_multisig.operation_map
    )
    return [operations, {...storage_multisig, operation_map: final_operation_map}];
};

