#import "types.jsligo" "T"
#import "error.jsligo" "E"

// -----------------
// --  CONSTANTS  --
// -----------------
const no_operation:  list<operation> = list([]);


// -----------------
// --  INTERNALS  --
// -----------------

const sendFA12 = ([token_amount, target_from, target_to, target_fa12] : [nat, address, address, address]): operation => {
    const fa12_contract_opt: option<contract<T.fa12_transfer>>  = Tezos.get_entrypoint_opt ("%transfer", target_fa12);
    const transfer_fa12: contract<T.fa12_transfer> = match (fa12_contract_opt, {
        Some: (c: contract<T.fa12_transfer>) => c,
        None: () => (failwith(E.unknown_contract_entrypoint) as contract<T.fa12_transfer>)
    });
    const transfer_param: T.fa12_transfer = [target_from, [target_to, token_amount]];
    return Tezos.transaction(transfer_param, 0 as mutez, transfer_fa12);
};


// ------------------
// -- ENTRY POINTS --
// ------------------

const create_proposal = ([params, storage_multisig]: [T.proposal_params, T.storage_multisig]): T.return_multisig => {
    assert_with_error(Set.mem(Tezos.sender, storage_multisig.signers), E.only_signer);
    assert_with_error (Tezos.amount == (0 as tez), E.amount_must_be_zero_tez);
    const new_proposal: T.proposal = {
        approved_signers: Set.empty as set<address>,
        executed: false,
        number_of_signers: 0 as nat,
        target_fa12: params.target_fa12,
        target_from: params.target_from,
        target_to: params.target_to,
        timestamp: Tezos.now,
        token_amount: params.token_amount
    };
    const proposal_map: big_map<nat, T.proposal> = Big_map.add(storage_multisig.proposal_counter, new_proposal, storage_multisig.proposal_map);
    return [no_operation, {...storage_multisig, proposal_counter: storage_multisig.proposal_counter + (1 as nat), proposal_map: proposal_map}]
};

const sign = ([proposal_id, storage_multisig]: [nat, T.storage_multisig]): T.return_multisig => {
    assert_with_error(Set.mem(Tezos.sender, storage_multisig.signers), E.only_signer);
    let target_request: T.proposal = match (Big_map.find_opt(proposal_id, storage_multisig.proposal_map), {
        Some: (op: T.proposal) => op,
        None: () => (failwith(E.no_operation_exist))
    });
    const _check_as_already_signed: unit = assert_with_error(Set.mem(Tezos.sender, storage_multisig.signers), E.has_already_signed); // quite useless
    target_request = ({
            ...target_request,
            approved_signers: Set.add(Tezos.sender, target_request.approved_signers),
            number_of_signers: target_request.number_of_signers + (1 as nat)
        });
    let operations: list<operation> = no_operation;
    if (Set.size(target_request.approved_signers) >= storage_multisig.threshold) {
        target_request = ({
            ...target_request,
            executed: true
        });
        operations = list([
            sendFA12(
                target_request.token_amount,
                target_request.target_from,
                target_request.target_to,
                target_request.target_fa12
            )
        ]);
    }
    const final_proposal_map: big_map<nat, T.proposal> = Big_map.update(
        proposal_id,
        Some(target_request),
        storage_multisig.proposal_map
    )
    return [operations, {...storage_multisig, proposal_map: final_proposal_map}];
};
